"use strict";(globalThis.webpackChunkbook_source=globalThis.webpackChunkbook_source||[]).push([[1022],{7039:(s,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"Physical-AI-Humanoid-Robotics/ros2-nervous-system/urdf-humanoid-basics.summary","title":"URDF for Humanoid Robots - Summary","description":"Quick Reference: Key concepts from this lesson","source":"@site/docs/13-Physical-AI-Humanoid-Robotics/01-ros2-nervous-system/04-urdf-humanoid-basics.summary.md","sourceDirName":"13-Physical-AI-Humanoid-Robotics/01-ros2-nervous-system","slug":"/Physical-AI-Humanoid-Robotics/ros2-nervous-system/urdf-humanoid-basics.summary","permalink":"/hackathon-phase-01/docs/Physical-AI-Humanoid-Robotics/ros2-nervous-system/urdf-humanoid-basics.summary","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/13-Physical-AI-Humanoid-Robotics/01-ros2-nervous-system/04-urdf-humanoid-basics.summary.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"URDF for Humanoid Robots","permalink":"/hackathon-phase-01/docs/Physical-AI-Humanoid-Robotics/ros2-nervous-system/urdf-humanoid-basics"},"next":{"title":"Capstone Project: Design a Delivery Robot System","permalink":"/hackathon-phase-01/docs/Physical-AI-Humanoid-Robotics/ros2-nervous-system/capstone-project"}}');var i=e(4848),r=e(8453);const t={},a="URDF for Humanoid Robots - Summary",l={},c=[{value:"Core Concept",id:"core-concept",level:2},{value:"Key Points",id:"key-points",level:2},{value:"When to Use",id:"when-to-use",level:2},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Related Concepts",id:"related-concepts",level:2}];function d(s){const n={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...s.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"urdf-for-humanoid-robots---summary",children:"URDF for Humanoid Robots - Summary"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Quick Reference"}),": Key concepts from this lesson"]}),"\n",(0,i.jsx)(n.h2,{id:"core-concept",children:"Core Concept"}),"\n",(0,i.jsx)(n.p,{children:"URDF (Unified Robot Description Format) is an XML-based format for describing robot physical structure through links (rigid body parts) and joints (connections with motion constraints), creating kinematic trees that enable simulation, visualization, and motion planning."}),"\n",(0,i.jsx)(n.h2,{id:"key-points",children:"Key Points"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Links Represent Body Parts"}),": Links define rigid bodies (torso, arms, legs, sensors) with visual geometry (cylinders, boxes, meshes), collision shapes, and inertial properties. Each link has a name and coordinate frame."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Joints Connect Links with Motion Constraints"}),": Joints specify parent-child relationships and motion type (revolute for rotation, prismatic for sliding, fixed for rigid connection). Each joint has limits (angle/distance ranges), axis of motion, and effort/velocity constraints."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Kinematic Trees Define Robot Structure"}),": URDF robots form hierarchical trees with one root link and parent-child relationships through joints. Moving a parent link moves all descendant links\u2014crucial for forward/inverse kinematics."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Standard Units and Conventions"}),": URDF requires meters (distance), radians (angles), kilograms (mass). Coordinate frames use right-hand rule (X=forward, Y=left, Z=up). Getting units wrong causes visualization/simulation errors."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Enables Simulation and Visualization"}),": Gazebo reads URDF for physics simulation (testing control safely). RViz reads URDF for 3D visualization (debugging in real-time). MoveIt reads URDF for motion planning (computing trajectories)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use",children:"When to Use"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"URDF is essential for"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simulation"}),": Testing robot behaviors in Gazebo before deploying to hardware"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Visualization"}),": Debugging robot state and movements in RViz"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Motion Planning"}),": Enabling libraries like MoveIt to compute collision-free trajectories"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Standardization"}),": Sharing robot models across teams and tools"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hardware Abstraction"}),": Developing algorithms independent of specific actuators"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Root link"})," (base_link or torso) serves as the kinematic tree root for mobile/humanoid robots"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Revolute joints"})," for rotating connections (shoulders, elbows, knees) with angle limits"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Visual geometry"})," uses simple shapes (cylinder, box) for limbs; complex meshes (STL, DAE) for detailed models"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Origin tags"})," position joints relative to parent link frames using xyz (meters) and rpy (radians)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Joint limits"})," constrain motion to realistic ranges based on physical hardware or biological analogs"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"related-concepts",children:"Related Concepts"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Previous Lessons"}),": ROS2 Fundamentals (Lesson 1), Communication Patterns (Lesson 2), Python rclpy (Lesson 3)\u2014URDF completes the foundational knowledge"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Next Steps"}),": Capstone Project integrating all concepts (multi-node ROS2 system + URDF model)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Advanced Topics"}),": Xacro (XML macros for parameterized URDF), SDF (Simulation Description Format), mesh generation, sensor integration"]}),"\n"]})]})}function h(s={}){const{wrapper:n}={...(0,r.R)(),...s.components};return n?(0,i.jsx)(n,{...s,children:(0,i.jsx)(d,{...s})}):d(s)}},8453:(s,n,e)=>{e.d(n,{R:()=>t,x:()=>a});var o=e(6540);const i={},r=o.createContext(i);function t(s){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof s?s(n):{...n,...s}},[n,s])}function a(s){let n;return n=s.disableParentContext?"function"==typeof s.components?s.components(i):s.components||i:t(s.components),o.createElement(r.Provider,{value:n},s.children)}}}]);